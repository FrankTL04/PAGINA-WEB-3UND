{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title-block: false\n",
        "title-block-style: none\n",
        "\n",
        "format:\n",
        "  html:\n",
        "    toc: true\n",
        "    toc-location: left\n",
        "    theme:\n",
        "      light: cosmo\n",
        "      dark: cyborg\n",
        "    toggle: true\n",
        "---\n",
        "\n",
        "```{=html}\n",
        "<div style=\"display:flex; justify-content:space-between; align-items:flex-start; margin-top:20px;\">\n",
        "\n",
        "  <div style=\"width:70%;\">\n",
        "    <h1>FENOTIPADO DE HOJAS DE N√çSPERO <em>(Eriobotrya japonica)</em> CON SOFTWARE AUTOMATIZADO EMPLEANDO IA</h1>\n",
        "\n",
        "    <p><strong>Autores:</strong><br>\n",
        "    Colunche Vasquez, Josue J.; Cubas Fernandez, Mikey D.; Delgado Gomez, Mark A;Ramos Brice√±os, Iv√°n; S√°nchez Alvarado, Rub√©n; Tomapasca L√≥pez, Frank</p>\n",
        "  </div>\n",
        "\n",
        "  <div style=\"width:30%; position:relative;\">\n",
        "\n",
        "    <div style=\"position:absolute; top:0; right:0; z-index:10;\">\n",
        "      <quarto-toggle-theme></quarto-toggle-theme>\n",
        "    </div>\n",
        "\n",
        "    <img src=\"images/20.png\" style=\"width:100%; border-radius:12px; margin-top:45px;\">\n",
        "  </div>\n",
        "\n",
        "</div>\n",
        "```\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "## Resumen\n",
        "\n",
        "\n",
        "\n",
        "## Introducci√≥n\n",
        "\n",
        "El fenotipado vegetal constituye una herramienta fundamental para comprender la variabilidad morfol√≥gica y funcional de las plantas, permitiendo relacionar sus caracter√≠sticas externas con procesos fisiol√≥gicos, gen√©ticos y ambientales. En los √∫ltimos a√±os, el desarrollo de herramientas digitales y t√©cnicas de an√°lisis de im√°genes ha facilitado la evaluaci√≥n precisa, r√°pida y reproducible de rasgos fenot√≠picos, superando las limitaciones de los m√©todos manuales tradicionales.\n",
        "\n",
        "El n√≠spero (*Eriobotrya japonica*) es una especie frutal de importancia creciente debido a su valor nutricional, sus propiedades nutrac√©uticas y su adaptaci√≥n a diversos entornos agr√≠colas. El estudio detallado de la morfolog√≠a de sus hojas aporta informaci√≥n clave para la selecci√≥n de genotipos, el monitoreo del estado fisiol√≥gico y la identificaci√≥n de respuestas al manejo agron√≥mico o a factores ambientales.\n",
        "\n",
        "En este trabajo se desarrolla un proceso de fenotipado automatizado de hojas de n√≠spero, empleando t√©cnicas de an√°lisis de im√°genes a partir de fotograf√≠as estandarizadas. Para la automatizaci√≥n y procesamiento computacional se utiliz√≥ Google Colab, lo que permiti√≥ integrar librer√≠as de visi√≥n computacional, segmentaci√≥n y medici√≥n morfol√≥gica dentro de un entorno reproducible y accesible.\n",
        "\n",
        "Esta metodolog√≠a facilita la medici√≥n de caracter√≠sticas como √°rea foliar, per√≠metro, longitud, ancho y otros rasgos cuantitativos, contribuyendo a estudios de fenotipado de bajo costo y alta eficiencia. La implementaci√≥n de software automatizado en el fenotipado vegetal representa un avance significativo hacia pr√°cticas m√°s precisas, objetivas y escalables, especialmente en cultivos de inter√©s agron√≥mico como el n√≠spero. Este enfoque abre oportunidades para mejorar la caracterizaci√≥n morfol√≥gica y apoyar investigaciones orientadas a la productividad, adaptaci√≥n y selecci√≥n varietal.\n",
        "\n",
        "\n",
        "\n",
        "## Objetivos\n",
        "\n",
        "### Objetivo general\n",
        "\n",
        "Realizar el fenotipado automatizado de hojas de n√≠spero (*Eriobotrya japonica*) mediante herramientas de an√°lisis de im√°genes en Google Colab, con el fin de obtener mediciones morfol√≥gicas precisas y reproducibles.\n",
        "\n",
        "### Objetivos espec√≠ficos\n",
        "\n",
        "1. Capturar y estandarizar im√°genes de hojas de n√≠spero empleando una escala de referencia para el c√°lculo de medidas reales.  \n",
        "2. Implementar un flujo de procesamiento digital utilizando Google Colab y librer√≠as de visi√≥n computacional.  \n",
        "3. Segmentar las hojas y extraer caracter√≠sticas morfol√≥gicas clave como √°rea, longitud y ancho.  \n",
        "4. Evaluar la precisi√≥n y eficiencia del m√©todo automatizado frente a mediciones manuales o tradicionales.  \n",
        "5. Generar un conjunto de datos morfom√©tricos que pueda emplearse en estudios posteriores de variabilidad, selecci√≥n o caracterizaci√≥n agron√≥mica.\n",
        "\n",
        "\n",
        "\n",
        "## Marco Te√≥rico\n",
        "\n",
        "### Fenotipado Vegetal\n",
        "\n",
        "El fenotipado vegetal es el conjunto de t√©cnicas empleadas para cuantificar y analizar las caracter√≠sticas observables de las plantas, incluyendo rasgos morfol√≥gicos, fisiol√≥gicos y bioqu√≠micos. Estas caracter√≠sticas resultan de la interacci√≥n entre la expresi√≥n gen√©tica y las condiciones ambientales.\n",
        "\n",
        "Tradicionalmente, el fenotipado se ha realizado mediante mediciones manuales, las cuales son laboriosas, lentas y sujetas a errores asociados al observador. Como respuesta a estas limitaciones, se han desarrollado m√©todos de fenotipado automatizado que utilizan tecnolog√≠as de visi√≥n por computadora y an√°lisis de im√°genes para obtener mediciones precisas y reproducibles.\n",
        "\n",
        "\n",
        "\n",
        "### Fenotipado automatizado mediante an√°lisis de im√°genes\n",
        "\n",
        "El an√°lisis de im√°genes se ha convertido en una herramienta poderosa para el fenotipado de plantas debido a su capacidad para capturar y procesar grandes cantidades de informaci√≥n de forma r√°pida y objetiva. Mediante la aplicaci√≥n de algoritmos de segmentaci√≥n, detecci√≥n de contornos y c√°lculo geom√©trico, es posible extraer rasgos morfol√≥gicos como √°rea foliar, per√≠metro, longitud, forma y patrones de venaci√≥n.\n",
        "\n",
        "El fenotipado automatizado presenta varias ventajas:\n",
        "\n",
        "1. Reduce el tiempo y esfuerzo manual.  \n",
        "2. Minimiza la subjetividad del evaluador.  \n",
        "3. Permite analizar grandes conjuntos de datos.  \n",
        "4. Facilita la creaci√≥n de metodolog√≠as reproducibles.\n",
        "\n",
        "Herramientas como Python, OpenCV y plataformas como Google Colab han hecho accesible este tipo de an√°lisis incluso para usuarios sin hardware especializado.\n",
        "\n",
        "\n",
        "\n",
        "### Importancia de las hojas como √≥rgano de estudio\n",
        "\n",
        "Las hojas constituyen el principal sitio de fotos√≠ntesis, intercambio gaseoso y regulaci√≥n h√≠drica. La morfolog√≠a foliar como √°rea, forma, margen y arquitectura de nervaduras; est√° estrechamente relacionada con procesos fisiol√≥gicos y con la adaptaci√≥n de las plantas a condiciones ambientales espec√≠ficas.\n",
        "\n",
        "El estudio foliar permite inferir:\n",
        "\n",
        "1. La eficiencia fotosint√©tica  \n",
        "2. El estado h√≠drico  \n",
        "3. Respuestas a estr√©s bi√≥tico y abi√≥tico  \n",
        "4. Caracter√≠sticas gen√©ticas asociadas a productividad  \n",
        "5. Variaci√≥n intra e intervarietal  \n",
        "\n",
        "### ¬øQu√© es Google Colab?\n",
        "Google Colaboratory, conocido popularmente como Google Colab, es una plataforma gratuita ofrecida por Google que proporciona un entorno de cuadernos Jupyter alojado en la nube. Permite escribir y ejecutar c√≥digo en Python, as√≠ como visualizar los resultados directamente desde el navegador, sin necesidad de realizar configuraciones ni instalar software de manera local (Vieira, 2024).\n",
        "\n",
        "\n",
        "## Metodolog√≠a\n",
        "\n",
        "### Material vegetal\n",
        "\n",
        "Se recolectaron hojas de n√≠spero (*Eriobotrya japonica*) provenientes de plantas sanas y en estado fisiol√≥gico comparable. Las muestras se seleccionaron asegurando variabilidad en tama√±o y forma.\n",
        "\n",
        "\n",
        "\n",
        "### Captura de im√°genes\n",
        "\n",
        "Las hojas fueron fotografiadas en un fondo blanco, incluyendo una moneda como escala para convertir medidas en p√≠xeles a unidades reales. Las im√°genes se capturaron bajo iluminaci√≥n uniforme para evitar sombras y facilitar la segmentaci√≥n.\n",
        "\n",
        "::: {#fig-imaje12 .center}\n",
        "![Hoja analizada](images/IMAJE_12.png){width=\"55%\"}\n",
        "Figura 1. Imagen analizada.\n",
        ":::\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "### Procesamiento en Google Colab\n",
        "\n",
        "```{bash}\n",
        "!pip install openpyxl\n",
        "\n",
        "import cv2\n",
        "import numpy as np\n",
        "import os\n",
        "import pandas as pd\n",
        "from google.colab.patches import cv2_imshow\n",
        "from google.colab import files\n",
        "import shutil\n",
        "\n",
        "DIAMETRO_REAL_MM = 25.5\n",
        "\n",
        "print(\"üì∏ Sube tus im√°genes de hojas (JPG, PNG):\")\n",
        "uploaded = files.upload()\n",
        "\n",
        "folder_path = \"/content/hojas/\"\n",
        "if os.path.exists(folder_path):\n",
        "    shutil.rmtree(folder_path)\n",
        "os.mkdir(folder_path)\n",
        "\n",
        "for fname, file in uploaded.items():\n",
        "    with open(os.path.join(folder_path, fname), \"wb\") as f:\n",
        "        f.write(file)\n",
        "print(\"‚úî Im√°genes cargadas en /content/hojas/\")\n",
        "\n",
        "def detectar_moneda_mm(img):\n",
        "    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n",
        "    gray_blur = cv2.GaussianBlur(gray, (9, 9), 1.5)\n",
        "\n",
        "    circles = cv2.HoughCircles(\n",
        "        gray_blur, cv2.HOUGH_GRADIENT, dp=1.2, minDist=80,\n",
        "        param1=80, param2=30, minRadius=20, maxRadius=200\n",
        "    )\n",
        "\n",
        "    if circles is not None:\n",
        "        circles = np.uint16(np.around(circles))\n",
        "        x, y, r = circles[0][0]\n",
        "\n",
        "        diameter_px = 2 * r\n",
        "        mm_per_pixel = DIAMETRO_REAL_MM / diameter_px\n",
        "\n",
        "        cv2.circle(img, (x, y), r, (0, 255, 0), 3)\n",
        "        cv2.circle(img, (x, y), 2, (0, 0, 255), 4)\n",
        "\n",
        "        return img, mm_per_pixel, (x, y, r)\n",
        "\n",
        "    return img, None, None\n",
        "\n",
        "def medir_hoja_mm(img, mm_per_pixel):\n",
        "    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n",
        "    thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)[1]\n",
        "\n",
        "    kernel = np.ones((5,5), np.uint8)\n",
        "    thresh = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel, iterations=2)\n",
        "\n",
        "    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n",
        "\n",
        "    if not contours:\n",
        "        return None\n",
        "\n",
        "    c = max(contours, key=cv2.contourArea)\n",
        "    area_pix = cv2.contourArea(c)\n",
        "\n",
        "    pts = c.reshape(-1, 2).astype(np.float32)\n",
        "\n",
        "    mean, eigenvectors, eigenvalues = cv2.PCACompute2(pts, mean=np.array([]))\n",
        "\n",
        "    longitud_pix = 2 * np.sqrt(eigenvalues[0][0])\n",
        "    ancho_pix = 2 * np.sqrt(eigenvalues[1][0])\n",
        "\n",
        "    longitud_mm = longitud_pix * mm_per_pixel\n",
        "    ancho_mm = ancho_pix * mm_per_pixel\n",
        "    area_mm2 = area_pix * (mm_per_pixel ** 2)\n",
        "\n",
        "    img_draw = img.copy()\n",
        "    center = tuple(np.int32(mean[0]))\n",
        "\n",
        "    p1 = center + np.int32(eigenvectors[0] * longitud_pix/2)\n",
        "    p2 = center - np.int32(eigenvectors[0] * longitud_pix/2)\n",
        "    cv2.line(img_draw, tuple(p1), tuple(p2), (0,0,255), 3)\n",
        "\n",
        "    p3 = center + np.int32(eigenvectors[1] * ancho_pix/2)\n",
        "    p4 = center - np.int32(eigenvectors[1] * ancho_pix/2)\n",
        "    cv2.line(img_draw, tuple(p3), tuple(p4), (255,0,0), 3)\n",
        "\n",
        "    return {\n",
        "        \"longitud_mm\": longitud_mm,\n",
        "        \"ancho_mm\": ancho_mm,\n",
        "        \"area_mm2\": area_mm2,\n",
        "        \"img_draw\": img_draw\n",
        "    }\n",
        "\n",
        "def procesar_carpeta(ruta):\n",
        "    resultados = []\n",
        "    imagenes_generadas = []\n",
        "\n",
        "    for fname in sorted(os.listdir(ruta)):\n",
        "        if not fname.lower().endswith((\".jpg\", \".jpeg\", \".png\")):\n",
        "            continue\n",
        "\n",
        "        img_path = os.path.join(ruta, fname)\n",
        "        img = cv2.imread(img_path)\n",
        "\n",
        "        img_mark, mm_per_pixel, _ = detectar_moneda_mm(img.copy())\n",
        "\n",
        "        if mm_per_pixel is None:\n",
        "            print(f\"‚ùå No se detect√≥ la moneda en {fname}\")\n",
        "            continue\n",
        "\n",
        "        datos = medir_hoja_mm(img.copy(), mm_per_pixel)\n",
        "\n",
        "        if datos is None:\n",
        "            print(f\"‚ùå No se pudo medir la hoja en {fname}\")\n",
        "            continue\n",
        "\n",
        "        resultados.append([\n",
        "            fname,\n",
        "            datos[\"longitud_mm\"],\n",
        "            datos[\"ancho_mm\"],\n",
        "            datos[\"area_mm2\"]\n",
        "        ])\n",
        "\n",
        "        imagenes_generadas.append((fname, datos[\"img_draw\"]))\n",
        "\n",
        "        print(f\"‚úî {fname} | Long: {datos['longitud_mm']:.2f} mm | \"\n",
        "              f\"Ancho: {datos['ancho_mm']:.2f} mm | \"\n",
        "              f\"√Årea: {datos['area_mm2']:.2f} mm¬≤\")\n",
        "\n",
        "    df = pd.DataFrame(resultados, columns=[\"Imagen\", \"Longitud_mm\", \"Ancho_mm\", \"Area_mm2\"])\n",
        "    return df, imagenes_generadas\n",
        "\n",
        "df, imgs = procesar_carpeta(\"/content/hojas/\")\n",
        "\n",
        "print(\"\\nüìä RESULTADOS:\")\n",
        "display(df)\n",
        "\n",
        "df.to_excel(\"resultados_hojas.xlsx\", index=False)\n",
        "print(\"\\nüìÅ Archivo generado: resultados_hojas.xlsx\")\n",
        "\n",
        "print(\"\\nüñº Mostrando im√°genes procesadas:\")\n",
        "for name, image in imgs:\n",
        "    print(\"Imagen:\", name)\n",
        "    cv2_imshow(image)\n",
        "\n",
        "```\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "#### Carga de im√°genes  \n",
        "\n",
        "\n",
        "\n",
        "#### Detecci√≥n de escala  \n",
        "::: {#fig-imaje12 .center}\n",
        "![Hoja analizada](images/WhatsApp Image 2025-12-09 at 11.14.43 AM (2).jpeg){width=\"55%\"}\n",
        "\n",
        "\n",
        "#### Extracci√≥n de rasgos morfol√≥gicos  \n",
        "\n",
        "\n",
        "\n",
        "#### Exportaci√≥n de resultados\n",
        "\n",
        "::: {#fig-imaje12 .center}\n",
        "![Hoja analizada](images/){width=\"55%\"}\n",
        "\n",
        "::: {#fig-imaje12 .center}\n",
        "![Hoja analizada](images/WhatsApp Image 2025-12-09 at 11.14.42 AM.jpeg){width=\"55%\"}\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "::: {#fig-imaje12 .center}\n",
        "![Hoja analizada](images/WhatsApp Image 2025-12-09 at 11.14.42 AM (1).jpeg){width=\"55%\"}\n",
        "\n",
        "\n",
        "::: {#fig-imaje12 .center}\n",
        "![Hoja analizada](images/WhatsApp Image 2025-12-09 at 10.44.48 AM.jpeg){width=\"55%\"}\n",
        "Figura 1. Tabla de resultados.\n",
        ":::\n",
        "\n",
        "\n",
        "\n",
        "## Referencias Bibliogr√°ficas\n"
      ],
      "id": "038f808c"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}